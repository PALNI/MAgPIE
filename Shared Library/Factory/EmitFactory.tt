<#@ template language="C#" debug="True" #>
<#@ output extension="cs" #>
<#@ include file="T4Toolbox.tt" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#
// <copyright file="EmitFactoryGenerator.tt" company="">
//  Copyright Â© . All Rights Reserved.
// </copyright>

	Int32 methodArgumentMax = 4;
	Int32 constructorArgumentMax = 4;

	String classNameFormat = "EmitFactory{0}";
	String instanceType = "TInstance";
	String concreteType = "TConcrete";
	String delegateType = "ConstructorDelegate";
	String methodArgumentTypeFormat = "TMethodArg{0}";
	String methodArgumentNameFormat = "methodArg{0}";
	String constructorArgumentTypeFormat = "TConstructorArg{0}";
	String constructorArgumentNameFormat = "constructorArg{0}";

	String[] numbers = new String[] { "no", "one", "two", "three", "four", "five", "six", "seven", "eight" };
	String[] ordinals = new String[] { "", "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth" };

#>
//----------------------------------------------------------------------------------------------------
// This code was generated by a tool (<#= DateTime.Now.ToString() #>).
//----------------------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;

namespace ZondervanLibrary.SharedLibrary.Factory
{
<#
	List<String> methodTypes = new List<String>() { };
	List<String> constructorTypes = new List<String>() { };
	List<String> classTypes = new List<String>() { instanceType, concreteType };
	List<String> factoryTypes = new List<String>() { instanceType };
	List<String> typeofTypes = new List<String>() { };
	List<String> constructorDeclaration = new List<String>() { };
	List<String> methodDeclaration = new List<String>() { };
	List<String> fullDeclaration = new List<String>() { };
	List<String> fullArguments = new List<String>() { };
	List<String> methodArguments = new List<String>() { };

	for (int methodArgs = 0; methodArgs <= methodArgumentMax; methodArgs++)
	{
		String className = String.Format(classNameFormat, methodArgs);
#>

#region <#= className #> Overloads

<#
		for (int constructorArgs = 0; constructorArgs <= constructorArgumentMax; constructorArgs++)
		{
			
#>
	/// <summary>Provides a factory whose constructor has <#= numbers[constructorArgs] #> arguments and whose factory method has <#= numbers[methodArgs] #> arguments.</summary>
	/// <typeparam name="<#= instanceType #>">The type of instance to create.</typeparam>
	/// <typeparam name="<#= concreteType #>">The type derived from instance whose constructor we should invoke.</typeparam>
<#
	for (int i = 1; i <= methodArgs; i++)
	{
#>
	/// <typeparam name="<#= String.Format(methodArgumentTypeFormat, i) #>">The <#= ordinals[i] #> argument to the factory method which will be the <#= ordinals[i] #> argument to the constructor of <typeparamref name="<#= concreteType #>"/>.</typeparam>
<#
	}
	for (int i = 1; i <= constructorArgs; i++)
	{
#>
	/// <typeparam name="<#= String.Format(constructorArgumentTypeFormat, i) #>">The <#= ordinals[i] #> argument to the constructor which will be the <#= ordinals[i + methodArgs] #> argument to the constructor of <typeparamref name="<#= concreteType #>"/>.</typeparam>
<#
	}
#>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="<#= concreteType #>"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class <#= className #><<#= String.Join(", ", classTypes) #>> : IFactory<<#= String.Join(", ", factoryTypes) #>>
		where <#= concreteType #> : <#= instanceType #>
	{
		private delegate <#= concreteType #> <#= delegateType #>(<#= String.Join(", ", fullDeclaration) #>);
		private readonly <#= delegateType #> _delegate;
<#
		for (int i = 1; i <= constructorArgs; i++)
		{
#>
		private readonly <#= String.Format(constructorArgumentTypeFormat, i) #> _<#= String.Format(constructorArgumentNameFormat, i) #>;
<#
		}
#>

		/// <summary>Creates a new instance of <see cref="<#= className #>{<#= String.Join(",", classTypes) #>}" />.</summary>
<#
		for (int i = 1; i <= constructorArgs; i++)
		{
#>
		/// <param name="<#= String.Format(constructorArgumentNameFormat, i) #>">The <#= ordinals[i] #> constructor argument.</param>
<#
		}
#>
		/// <exception cref="System.ArgumentException"><typeparamref name="<#= concreteType #>" /> has no constructor matching the type signature of <c><#= concreteType #>(<#= String.Join(",", constructorTypes) #>)</c>.</exception>
		public <#= className #>(<#= String.Join(", ", constructorDeclaration) #>)
		{
			_delegate = EmitDelegate.CreateConstructor<<#= delegateType #>>();
<#
		for (int i = 1; i <= constructorArgs; i++)
		{
#>
			_<#= String.Format(constructorArgumentNameFormat, i) #> = <#= String.Format(constructorArgumentNameFormat, i) #>;
<#
		}
#>
		}

		/// <inheritdoc cref="IFactory{<#= String.Join(",", factoryTypes) #>}" />
		public <#= instanceType #> CreateInstance(<#= String.Join(", ", methodDeclaration) #>)
		{
			return _delegate(<#= String.Join(", ", fullArguments) #>);
		}
	}

<#
			String constructorType = String.Format(constructorArgumentTypeFormat, constructorArgs + 1); 
			String constructorName = String.Format(constructorArgumentNameFormat, constructorArgs + 1);
			constructorTypes.Add(constructorType);
			classTypes.Add(constructorType);
			typeofTypes.Add(String.Format("typeof({0})", constructorType));

			String declaration = String.Format("{0} {1}", constructorType, constructorName);
			constructorDeclaration.Add(declaration); 
			fullDeclaration.Add(declaration);
			fullArguments.Add(String.Format("_{0}", constructorName));
		}
#>

#endregion

<#
		String methodType = String.Format(methodArgumentTypeFormat, methodArgs + 1);
		String methodName = String.Format(methodArgumentNameFormat, methodArgs + 1);
		methodTypes.Add(methodType);
		methodArguments.Add(methodName);
		constructorTypes.Clear();
		classTypes = new List<String>() { instanceType, concreteType };
		classTypes.AddRange(methodTypes);
		factoryTypes.Add(methodType);
		typeofTypes = methodTypes.Select(m => String.Format("typeof({0})", m)).ToList();
		constructorDeclaration.Clear();

		String decl = String.Format("{0} {1}", methodType, methodName);
		methodDeclaration.Add(decl);
		fullDeclaration = new List<String>(methodDeclaration);
		fullArguments = new List<String>(methodArguments);
	}
#>
}