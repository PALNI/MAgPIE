//----------------------------------------------------------------------------------------------------
// This code was generated by a tool (5/11/2015 4:45:32 PM).
//----------------------------------------------------------------------------------------------------

namespace ZondervanLibrary.SharedLibrary.Factory
{

#region EmitFactory0 Overloads

	/// <summary>Provides a factory whose constructor has no arguments and whose factory method has no arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory0<TInstance, TConcrete> : IFactory<TInstance>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate();
		private readonly ConstructorDelegate _delegate;

		/// <summary>Creates a new instance of <see cref="EmitFactory0{TInstance,TConcrete}" />.</summary>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete()</c>.</exception>
		public EmitFactory0()
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
		}

		/// <inheritdoc cref="IFactory{TInstance}" />
		public TInstance CreateInstance()
		{
			return _delegate();
		}
	}

	/// <summary>Provides a factory whose constructor has one arguments and whose factory method has no arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory0<TInstance, TConcrete, TConstructorArg1> : IFactory<TInstance>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TConstructorArg1 constructorArg1);
		private static readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;

        static EmitFactory0()
        {
            _delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
        }

		/// <summary>Creates a new instance of <see cref="EmitFactory0{TInstance,TConcrete,TConstructorArg1}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1)</c>.</exception>
		public EmitFactory0(TConstructorArg1 constructorArg1)
		{
			_constructorArg1 = constructorArg1;
		}

		/// <inheritdoc cref="IFactory{TInstance}" />
		public TInstance CreateInstance()
		{
			return _delegate(_constructorArg1);
		}
	}

	/// <summary>Provides a factory whose constructor has two arguments and whose factory method has no arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory0<TInstance, TConcrete, TConstructorArg1, TConstructorArg2> : IFactory<TInstance>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;

		/// <summary>Creates a new instance of <see cref="EmitFactory0{TInstance,TConcrete,TConstructorArg1,TConstructorArg2}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2)</c>.</exception>
		public EmitFactory0(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
		}

		/// <inheritdoc cref="IFactory{TInstance}" />
		public TInstance CreateInstance()
		{
			return _delegate(_constructorArg1, _constructorArg2);
		}
	}

	/// <summary>Provides a factory whose constructor has three arguments and whose factory method has no arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg3">The third argument to the constructor which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory0<TInstance, TConcrete, TConstructorArg1, TConstructorArg2, TConstructorArg3> : IFactory<TInstance>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;
		private readonly TConstructorArg3 _constructorArg3;

		/// <summary>Creates a new instance of <see cref="EmitFactory0{TInstance,TConcrete,TConstructorArg1,TConstructorArg2,TConstructorArg3}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <param name="constructorArg3">The third constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2,TConstructorArg3)</c>.</exception>
		public EmitFactory0(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
			_constructorArg3 = constructorArg3;
		}

		/// <inheritdoc cref="IFactory{TInstance}" />
		public TInstance CreateInstance()
		{
			return _delegate(_constructorArg1, _constructorArg2, _constructorArg3);
		}
	}

	/// <summary>Provides a factory whose constructor has four arguments and whose factory method has no arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg3">The third argument to the constructor which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg4">The fourth argument to the constructor which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory0<TInstance, TConcrete, TConstructorArg1, TConstructorArg2, TConstructorArg3, TConstructorArg4> : IFactory<TInstance>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3, TConstructorArg4 constructorArg4);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;
		private readonly TConstructorArg3 _constructorArg3;
		private readonly TConstructorArg4 _constructorArg4;

		/// <summary>Creates a new instance of <see cref="EmitFactory0{TInstance,TConcrete,TConstructorArg1,TConstructorArg2,TConstructorArg3,TConstructorArg4}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <param name="constructorArg3">The third constructor argument.</param>
		/// <param name="constructorArg4">The fourth constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2,TConstructorArg3,TConstructorArg4)</c>.</exception>
		public EmitFactory0(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3, TConstructorArg4 constructorArg4)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
			_constructorArg3 = constructorArg3;
			_constructorArg4 = constructorArg4;
		}

		/// <inheritdoc cref="IFactory{TInstance}" />
		public TInstance CreateInstance()
		{
			return _delegate(_constructorArg1, _constructorArg2, _constructorArg3, _constructorArg4);
		}
	}


#endregion


#region EmitFactory1 Overloads

	/// <summary>Provides a factory whose constructor has no arguments and whose factory method has one arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory1<TInstance, TConcrete, TMethodArg1> : IFactory<TInstance, TMethodArg1>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1);
		private readonly ConstructorDelegate _delegate;

		/// <summary>Creates a new instance of <see cref="EmitFactory1{TInstance,TConcrete,TMethodArg1}" />.</summary>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete()</c>.</exception>
		public EmitFactory1()
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1)
		{
			return _delegate(methodArg1);
		}
	}

	/// <summary>Provides a factory whose constructor has one arguments and whose factory method has one arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory1<TInstance, TConcrete, TMethodArg1, TConstructorArg1> : IFactory<TInstance, TMethodArg1>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TConstructorArg1 constructorArg1);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;

		/// <summary>Creates a new instance of <see cref="EmitFactory1{TInstance,TConcrete,TMethodArg1,TConstructorArg1}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1)</c>.</exception>
		public EmitFactory1(TConstructorArg1 constructorArg1)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1)
		{
			return _delegate(methodArg1, _constructorArg1);
		}
	}

	/// <summary>Provides a factory whose constructor has two arguments and whose factory method has one arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory1<TInstance, TConcrete, TMethodArg1, TConstructorArg1, TConstructorArg2> : IFactory<TInstance, TMethodArg1>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;

		/// <summary>Creates a new instance of <see cref="EmitFactory1{TInstance,TConcrete,TMethodArg1,TConstructorArg1,TConstructorArg2}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2)</c>.</exception>
		public EmitFactory1(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1)
		{
			return _delegate(methodArg1, _constructorArg1, _constructorArg2);
		}
	}

	/// <summary>Provides a factory whose constructor has three arguments and whose factory method has one arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg3">The third argument to the constructor which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory1<TInstance, TConcrete, TMethodArg1, TConstructorArg1, TConstructorArg2, TConstructorArg3> : IFactory<TInstance, TMethodArg1>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;
		private readonly TConstructorArg3 _constructorArg3;

		/// <summary>Creates a new instance of <see cref="EmitFactory1{TInstance,TConcrete,TMethodArg1,TConstructorArg1,TConstructorArg2,TConstructorArg3}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <param name="constructorArg3">The third constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2,TConstructorArg3)</c>.</exception>
		public EmitFactory1(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
			_constructorArg3 = constructorArg3;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1)
		{
			return _delegate(methodArg1, _constructorArg1, _constructorArg2, _constructorArg3);
		}
	}

	/// <summary>Provides a factory whose constructor has four arguments and whose factory method has one arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg3">The third argument to the constructor which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg4">The fourth argument to the constructor which will be the fifth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory1<TInstance, TConcrete, TMethodArg1, TConstructorArg1, TConstructorArg2, TConstructorArg3, TConstructorArg4> : IFactory<TInstance, TMethodArg1>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3, TConstructorArg4 constructorArg4);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;
		private readonly TConstructorArg3 _constructorArg3;
		private readonly TConstructorArg4 _constructorArg4;

		/// <summary>Creates a new instance of <see cref="EmitFactory1{TInstance,TConcrete,TMethodArg1,TConstructorArg1,TConstructorArg2,TConstructorArg3,TConstructorArg4}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <param name="constructorArg3">The third constructor argument.</param>
		/// <param name="constructorArg4">The fourth constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2,TConstructorArg3,TConstructorArg4)</c>.</exception>
		public EmitFactory1(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3, TConstructorArg4 constructorArg4)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
			_constructorArg3 = constructorArg3;
			_constructorArg4 = constructorArg4;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1)
		{
			return _delegate(methodArg1, _constructorArg1, _constructorArg2, _constructorArg3, _constructorArg4);
		}
	}


#endregion


#region EmitFactory2 Overloads

	/// <summary>Provides a factory whose constructor has no arguments and whose factory method has two arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory2<TInstance, TConcrete, TMethodArg1, TMethodArg2> : IFactory<TInstance, TMethodArg1, TMethodArg2>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2);
		private readonly ConstructorDelegate _delegate;

		/// <summary>Creates a new instance of <see cref="EmitFactory2{TInstance,TConcrete,TMethodArg1,TMethodArg2}" />.</summary>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete()</c>.</exception>
		public EmitFactory2()
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2)
		{
			return _delegate(methodArg1, methodArg2);
		}
	}

	/// <summary>Provides a factory whose constructor has one arguments and whose factory method has two arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory2<TInstance, TConcrete, TMethodArg1, TMethodArg2, TConstructorArg1> : IFactory<TInstance, TMethodArg1, TMethodArg2>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TConstructorArg1 constructorArg1);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;

		/// <summary>Creates a new instance of <see cref="EmitFactory2{TInstance,TConcrete,TMethodArg1,TMethodArg2,TConstructorArg1}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1)</c>.</exception>
		public EmitFactory2(TConstructorArg1 constructorArg1)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2)
		{
			return _delegate(methodArg1, methodArg2, _constructorArg1);
		}
	}

	/// <summary>Provides a factory whose constructor has two arguments and whose factory method has two arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory2<TInstance, TConcrete, TMethodArg1, TMethodArg2, TConstructorArg1, TConstructorArg2> : IFactory<TInstance, TMethodArg1, TMethodArg2>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;

		/// <summary>Creates a new instance of <see cref="EmitFactory2{TInstance,TConcrete,TMethodArg1,TMethodArg2,TConstructorArg1,TConstructorArg2}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2)</c>.</exception>
		public EmitFactory2(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2)
		{
			return _delegate(methodArg1, methodArg2, _constructorArg1, _constructorArg2);
		}
	}

	/// <summary>Provides a factory whose constructor has three arguments and whose factory method has two arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg3">The third argument to the constructor which will be the fifth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory2<TInstance, TConcrete, TMethodArg1, TMethodArg2, TConstructorArg1, TConstructorArg2, TConstructorArg3> : IFactory<TInstance, TMethodArg1, TMethodArg2>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;
		private readonly TConstructorArg3 _constructorArg3;

		/// <summary>Creates a new instance of <see cref="EmitFactory2{TInstance,TConcrete,TMethodArg1,TMethodArg2,TConstructorArg1,TConstructorArg2,TConstructorArg3}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <param name="constructorArg3">The third constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2,TConstructorArg3)</c>.</exception>
		public EmitFactory2(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
			_constructorArg3 = constructorArg3;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2)
		{
			return _delegate(methodArg1, methodArg2, _constructorArg1, _constructorArg2, _constructorArg3);
		}
	}

	/// <summary>Provides a factory whose constructor has four arguments and whose factory method has two arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg3">The third argument to the constructor which will be the fifth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg4">The fourth argument to the constructor which will be the sixth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory2<TInstance, TConcrete, TMethodArg1, TMethodArg2, TConstructorArg1, TConstructorArg2, TConstructorArg3, TConstructorArg4> : IFactory<TInstance, TMethodArg1, TMethodArg2>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3, TConstructorArg4 constructorArg4);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;
		private readonly TConstructorArg3 _constructorArg3;
		private readonly TConstructorArg4 _constructorArg4;

		/// <summary>Creates a new instance of <see cref="EmitFactory2{TInstance,TConcrete,TMethodArg1,TMethodArg2,TConstructorArg1,TConstructorArg2,TConstructorArg3,TConstructorArg4}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <param name="constructorArg3">The third constructor argument.</param>
		/// <param name="constructorArg4">The fourth constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2,TConstructorArg3,TConstructorArg4)</c>.</exception>
		public EmitFactory2(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3, TConstructorArg4 constructorArg4)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
			_constructorArg3 = constructorArg3;
			_constructorArg4 = constructorArg4;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2)
		{
			return _delegate(methodArg1, methodArg2, _constructorArg1, _constructorArg2, _constructorArg3, _constructorArg4);
		}
	}


#endregion


#region EmitFactory3 Overloads

	/// <summary>Provides a factory whose constructor has no arguments and whose factory method has three arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg3">The third argument to the factory method which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory3<TInstance, TConcrete, TMethodArg1, TMethodArg2, TMethodArg3> : IFactory<TInstance, TMethodArg1, TMethodArg2, TMethodArg3>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3);
		private readonly ConstructorDelegate _delegate;

		/// <summary>Creates a new instance of <see cref="EmitFactory3{TInstance,TConcrete,TMethodArg1,TMethodArg2,TMethodArg3}" />.</summary>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete()</c>.</exception>
		public EmitFactory3()
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2,TMethodArg3}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3)
		{
			return _delegate(methodArg1, methodArg2, methodArg3);
		}
	}

	/// <summary>Provides a factory whose constructor has one arguments and whose factory method has three arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg3">The third argument to the factory method which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory3<TInstance, TConcrete, TMethodArg1, TMethodArg2, TMethodArg3, TConstructorArg1> : IFactory<TInstance, TMethodArg1, TMethodArg2, TMethodArg3>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TConstructorArg1 constructorArg1);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;

		/// <summary>Creates a new instance of <see cref="EmitFactory3{TInstance,TConcrete,TMethodArg1,TMethodArg2,TMethodArg3,TConstructorArg1}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1)</c>.</exception>
		public EmitFactory3(TConstructorArg1 constructorArg1)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2,TMethodArg3}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3)
		{
			return _delegate(methodArg1, methodArg2, methodArg3, _constructorArg1);
		}
	}

	/// <summary>Provides a factory whose constructor has two arguments and whose factory method has three arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg3">The third argument to the factory method which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the fifth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory3<TInstance, TConcrete, TMethodArg1, TMethodArg2, TMethodArg3, TConstructorArg1, TConstructorArg2> : IFactory<TInstance, TMethodArg1, TMethodArg2, TMethodArg3>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;

		/// <summary>Creates a new instance of <see cref="EmitFactory3{TInstance,TConcrete,TMethodArg1,TMethodArg2,TMethodArg3,TConstructorArg1,TConstructorArg2}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2)</c>.</exception>
		public EmitFactory3(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2,TMethodArg3}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3)
		{
			return _delegate(methodArg1, methodArg2, methodArg3, _constructorArg1, _constructorArg2);
		}
	}

	/// <summary>Provides a factory whose constructor has three arguments and whose factory method has three arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg3">The third argument to the factory method which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the fifth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg3">The third argument to the constructor which will be the sixth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory3<TInstance, TConcrete, TMethodArg1, TMethodArg2, TMethodArg3, TConstructorArg1, TConstructorArg2, TConstructorArg3> : IFactory<TInstance, TMethodArg1, TMethodArg2, TMethodArg3>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;
		private readonly TConstructorArg3 _constructorArg3;

		/// <summary>Creates a new instance of <see cref="EmitFactory3{TInstance,TConcrete,TMethodArg1,TMethodArg2,TMethodArg3,TConstructorArg1,TConstructorArg2,TConstructorArg3}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <param name="constructorArg3">The third constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2,TConstructorArg3)</c>.</exception>
		public EmitFactory3(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
			_constructorArg3 = constructorArg3;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2,TMethodArg3}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3)
		{
			return _delegate(methodArg1, methodArg2, methodArg3, _constructorArg1, _constructorArg2, _constructorArg3);
		}
	}

	/// <summary>Provides a factory whose constructor has four arguments and whose factory method has three arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg3">The third argument to the factory method which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the fifth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg3">The third argument to the constructor which will be the sixth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg4">The fourth argument to the constructor which will be the seventh argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory3<TInstance, TConcrete, TMethodArg1, TMethodArg2, TMethodArg3, TConstructorArg1, TConstructorArg2, TConstructorArg3, TConstructorArg4> : IFactory<TInstance, TMethodArg1, TMethodArg2, TMethodArg3>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3, TConstructorArg4 constructorArg4);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;
		private readonly TConstructorArg3 _constructorArg3;
		private readonly TConstructorArg4 _constructorArg4;

		/// <summary>Creates a new instance of <see cref="EmitFactory3{TInstance,TConcrete,TMethodArg1,TMethodArg2,TMethodArg3,TConstructorArg1,TConstructorArg2,TConstructorArg3,TConstructorArg4}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <param name="constructorArg3">The third constructor argument.</param>
		/// <param name="constructorArg4">The fourth constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2,TConstructorArg3,TConstructorArg4)</c>.</exception>
		public EmitFactory3(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3, TConstructorArg4 constructorArg4)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
			_constructorArg3 = constructorArg3;
			_constructorArg4 = constructorArg4;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2,TMethodArg3}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3)
		{
			return _delegate(methodArg1, methodArg2, methodArg3, _constructorArg1, _constructorArg2, _constructorArg3, _constructorArg4);
		}
	}


#endregion


#region EmitFactory4 Overloads

	/// <summary>Provides a factory whose constructor has no arguments and whose factory method has four arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg3">The third argument to the factory method which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg4">The fourth argument to the factory method which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory4<TInstance, TConcrete, TMethodArg1, TMethodArg2, TMethodArg3, TMethodArg4> : IFactory<TInstance, TMethodArg1, TMethodArg2, TMethodArg3, TMethodArg4>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TMethodArg4 methodArg4);
		private readonly ConstructorDelegate _delegate;

		/// <summary>Creates a new instance of <see cref="EmitFactory4{TInstance,TConcrete,TMethodArg1,TMethodArg2,TMethodArg3,TMethodArg4}" />.</summary>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete()</c>.</exception>
		public EmitFactory4()
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2,TMethodArg3,TMethodArg4}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TMethodArg4 methodArg4)
		{
			return _delegate(methodArg1, methodArg2, methodArg3, methodArg4);
		}
	}

	/// <summary>Provides a factory whose constructor has one arguments and whose factory method has four arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg3">The third argument to the factory method which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg4">The fourth argument to the factory method which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the fifth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory4<TInstance, TConcrete, TMethodArg1, TMethodArg2, TMethodArg3, TMethodArg4, TConstructorArg1> : IFactory<TInstance, TMethodArg1, TMethodArg2, TMethodArg3, TMethodArg4>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TMethodArg4 methodArg4, TConstructorArg1 constructorArg1);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;

		/// <summary>Creates a new instance of <see cref="EmitFactory4{TInstance,TConcrete,TMethodArg1,TMethodArg2,TMethodArg3,TMethodArg4,TConstructorArg1}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1)</c>.</exception>
		public EmitFactory4(TConstructorArg1 constructorArg1)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2,TMethodArg3,TMethodArg4}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TMethodArg4 methodArg4)
		{
			return _delegate(methodArg1, methodArg2, methodArg3, methodArg4, _constructorArg1);
		}
	}

	/// <summary>Provides a factory whose constructor has two arguments and whose factory method has four arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg3">The third argument to the factory method which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg4">The fourth argument to the factory method which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the fifth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the sixth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory4<TInstance, TConcrete, TMethodArg1, TMethodArg2, TMethodArg3, TMethodArg4, TConstructorArg1, TConstructorArg2> : IFactory<TInstance, TMethodArg1, TMethodArg2, TMethodArg3, TMethodArg4>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TMethodArg4 methodArg4, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;

		/// <summary>Creates a new instance of <see cref="EmitFactory4{TInstance,TConcrete,TMethodArg1,TMethodArg2,TMethodArg3,TMethodArg4,TConstructorArg1,TConstructorArg2}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2)</c>.</exception>
		public EmitFactory4(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2,TMethodArg3,TMethodArg4}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TMethodArg4 methodArg4)
		{
			return _delegate(methodArg1, methodArg2, methodArg3, methodArg4, _constructorArg1, _constructorArg2);
		}
	}

	/// <summary>Provides a factory whose constructor has three arguments and whose factory method has four arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg3">The third argument to the factory method which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg4">The fourth argument to the factory method which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the fifth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the sixth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg3">The third argument to the constructor which will be the seventh argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory4<TInstance, TConcrete, TMethodArg1, TMethodArg2, TMethodArg3, TMethodArg4, TConstructorArg1, TConstructorArg2, TConstructorArg3> : IFactory<TInstance, TMethodArg1, TMethodArg2, TMethodArg3, TMethodArg4>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TMethodArg4 methodArg4, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;
		private readonly TConstructorArg3 _constructorArg3;

		/// <summary>Creates a new instance of <see cref="EmitFactory4{TInstance,TConcrete,TMethodArg1,TMethodArg2,TMethodArg3,TMethodArg4,TConstructorArg1,TConstructorArg2,TConstructorArg3}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <param name="constructorArg3">The third constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2,TConstructorArg3)</c>.</exception>
		public EmitFactory4(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
			_constructorArg3 = constructorArg3;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2,TMethodArg3,TMethodArg4}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TMethodArg4 methodArg4)
		{
			return _delegate(methodArg1, methodArg2, methodArg3, methodArg4, _constructorArg1, _constructorArg2, _constructorArg3);
		}
	}

	/// <summary>Provides a factory whose constructor has four arguments and whose factory method has four arguments.</summary>
	/// <typeparam name="TInstance">The type of instance to create.</typeparam>
	/// <typeparam name="TConcrete">The type derived from instance whose constructor we should invoke.</typeparam>
	/// <typeparam name="TMethodArg1">The first argument to the factory method which will be the first argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg2">The second argument to the factory method which will be the second argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg3">The third argument to the factory method which will be the third argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TMethodArg4">The fourth argument to the factory method which will be the fourth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg1">The first argument to the constructor which will be the fifth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg2">The second argument to the constructor which will be the sixth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg3">The third argument to the constructor which will be the seventh argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <typeparam name="TConstructorArg4">The fourth argument to the constructor which will be the eighth argument to the constructor of <typeparamref name="TConcrete"/>.</typeparam>
	/// <remarks>
	///    <para>Ideally this class would be able to perform compile time type checking against the signature of the constructor of <typeparamref name="TConcrete"/>, but .NET currently does not support type constraints with constructors other than the default constructor.  Therefore we are forced to use reflection and can only throw a type/signature mismatch exception at runtime.</para>
	/// </remarks>
	public class EmitFactory4<TInstance, TConcrete, TMethodArg1, TMethodArg2, TMethodArg3, TMethodArg4, TConstructorArg1, TConstructorArg2, TConstructorArg3, TConstructorArg4> : IFactory<TInstance, TMethodArg1, TMethodArg2, TMethodArg3, TMethodArg4>
		where TConcrete : TInstance
	{
		private delegate TConcrete ConstructorDelegate(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TMethodArg4 methodArg4, TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3, TConstructorArg4 constructorArg4);
		private readonly ConstructorDelegate _delegate;
		private readonly TConstructorArg1 _constructorArg1;
		private readonly TConstructorArg2 _constructorArg2;
		private readonly TConstructorArg3 _constructorArg3;
		private readonly TConstructorArg4 _constructorArg4;

		/// <summary>Creates a new instance of <see cref="EmitFactory4{TInstance,TConcrete,TMethodArg1,TMethodArg2,TMethodArg3,TMethodArg4,TConstructorArg1,TConstructorArg2,TConstructorArg3,TConstructorArg4}" />.</summary>
		/// <param name="constructorArg1">The first constructor argument.</param>
		/// <param name="constructorArg2">The second constructor argument.</param>
		/// <param name="constructorArg3">The third constructor argument.</param>
		/// <param name="constructorArg4">The fourth constructor argument.</param>
		/// <exception cref="System.ArgumentException"><typeparamref name="TConcrete" /> has no constructor matching the type signature of <c>TConcrete(TConstructorArg1,TConstructorArg2,TConstructorArg3,TConstructorArg4)</c>.</exception>
		public EmitFactory4(TConstructorArg1 constructorArg1, TConstructorArg2 constructorArg2, TConstructorArg3 constructorArg3, TConstructorArg4 constructorArg4)
		{
			_delegate = EmitDelegate.CreateConstructor<ConstructorDelegate>();
			_constructorArg1 = constructorArg1;
			_constructorArg2 = constructorArg2;
			_constructorArg3 = constructorArg3;
			_constructorArg4 = constructorArg4;
		}

		/// <inheritdoc cref="IFactory{TInstance,TMethodArg1,TMethodArg2,TMethodArg3,TMethodArg4}" />
		public TInstance CreateInstance(TMethodArg1 methodArg1, TMethodArg2 methodArg2, TMethodArg3 methodArg3, TMethodArg4 methodArg4)
		{
			return _delegate(methodArg1, methodArg2, methodArg3, methodArg4, _constructorArg1, _constructorArg2, _constructorArg3, _constructorArg4);
		}
	}


#endregion

}